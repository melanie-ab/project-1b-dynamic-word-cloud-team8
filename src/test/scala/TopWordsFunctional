package TopWordsFunctional

import scala.io.Source
import scala.language.unsafeNulls
import scala.util.Try
import scala.collection.mutable
import com.typesafe.scalalogging.Logger
import javafx.application.Platform
import wordcount.wordCloudVisualizer

import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

// Trait for handling CLI arguments
trait Config {
  def handleArgs(args: Array[String]): Map[String, Int] = {
    val defaults = Map(
      "cloud-size" -> 10,
      "length-at-least" -> 6,
      "window-size" -> 1000,
      "min-frequency" -> 3,
      "update-every" -> 10
    )

    def safeParseInt(value: String, default: Int): Int =
      Try(value.toInt).getOrElse(default)

    val collectedArgs = args.grouped(2).collect {
      case Array("-c", v) => "cloud-size" -> safeParseInt(v, defaults("cloud-size"))
      case Array("--cloud-size", v) => "cloud-size" -> safeParseInt(v, defaults("cloud-size"))
      case Array("-l", v) => "length-at-least" -> safeParseInt(v, defaults("length-at-least"))
      case Array("--length-at-least", v) => "length-at-least" -> safeParseInt(v, defaults("length-at-least"))
      case Array("-w", v) => "window-size" -> safeParseInt(v, defaults("window-size"))
      case Array("--window-size", v) => "window-size" -> safeParseInt(v, defaults("window-size"))
      case Array("-f", v) => "min-frequency" -> safeParseInt(v, defaults("min-frequency"))
      case Array("--min-frequency", v) => "min-frequency" -> safeParseInt(v, defaults("min-frequency"))
      case Array("-u", v) => "update-every" -> safeParseInt(v, defaults("update-every"))
      case Array("--update-every", v) => "update-every" -> safeParseInt(v, defaults("update-every"))
    }.toMap

    defaults ++ collectedArgs
  }
}

// Trait for processing words with sliding window
trait WordProcessor {

  def processWords(
      words: Iterator[String],
      ignoredWords: Set[String],
      minLength: Int,
      windowSize: Int,
      updateEvery: Int
  ): Iterator[Map[String, Int]] = {

    val counts = mutable.Map.empty[String, Int]
    val window = mutable.Queue.empty[String]
    var counter = 0

    new Iterator[Map[String, Int]] {
      def hasNext: Boolean = words.hasNext
      def next(): Map[String, Int] = {
        while (words.hasNext) {
          val raw = words.next().toLowerCase.trim
          if (raw.length >= minLength && !ignoredWords.contains(raw)) {
            window.enqueue(raw)
            counts.update(raw, counts.getOrElse(raw, 0) + 1)
            if (window.size > windowSize) {
              val removed = window.dequeue()
              counts.update(removed, counts(removed) - 1)
              if (counts(removed) <= 0) counts.remove(removed)
            }
            counter += 1
            if (window.size == windowSize && counter % updateEvery == 0) {
              return counts.toMap
            }
          }
        }
        Map.empty[String, Int] // end of iterator
      }
    }
  }
}

// Trait for output handling
trait OutputHandler {
  val logger: Logger = Logger("TopWordsFunctional")

  def doOutput(output: String): Unit = {
    println(output)
  }

  def printWordCloud(wordCounts: Map[String, Int], cloudSize: Int, minFrequency: Int): String = {
    wordCounts
      .filter { case (_, count) => count >= minFrequency }
      .toSeq
      .sortBy { case (word, count) => (-count, word) }
      .take(cloudSize)
      .map { case (word, count) => s"$word: $count" }
      .mkString(" ")
  }
}

// Main object combining everything
object TopWordsFunctional extends Config with WordProcessor with OutputHandler {

  def main(args: Array[String]): Unit = {

    val wordCloudArgs = handleArgs(args)
    val cloudSize = wordCloudArgs("cloud-size")
    val minLength = wordCloudArgs("length-at-least")
    val windowSize = wordCloudArgs("window-size")
    val minFrequency = wordCloudArgs("min-frequency")
    val updateEvery = wordCloudArgs("update-every")

    logger.debug(s"cloudSize=$cloudSize, minLength=$minLength, windowSize=$windowSize, minFrequency=$minFrequency, updateEvery=$updateEvery")

    // Read ignore-list
    val ignoredWords: Set[String] = try {
      Source.fromFile("ignore-list").getLines().map(_.trim).filter(_.nonEmpty).toSet
    } catch {
      case e: Exception =>
        logger.error("Could not read ignore-list", e)
        Set.empty[String]
    }

    val words = Source.stdin.getLines().flatMap(line => line.split("""(?U)[^\p{Alpha}0-9']+"""))

    // Start JavaFX visualization (extra credit)
    Future { wordCloudVisualizer.main(Array.empty) }

    // Process words
    val processed = processWords(words, ignoredWords, minLength, windowSize, updateEvery)

    try {
      processed.foreach { counts =>
        if (counts.nonEmpty) {
          val wordCloud = printWordCloud(counts, cloudSize, minFrequency)
          doOutput(wordCloud)
          Platform.runLater(() => wordCloudVisualizer.getInstance().updateWordCloud(wordCloud))
        }
      }
    } catch {
      case _: java.io.IOException =>
        logger.info("Broken pipe detected. Exiting gracefully.")
        System.exit(0)
    }
  }
}

